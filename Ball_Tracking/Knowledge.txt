1.Knowledge01
图像矩
矩可以理解为图像的各类几何特征，详情请参考：[Image Moments]

M = cv2.moments(cnt)
M中包含了很多轮廓的特征信息，比如M['m00']表示轮廓面积，与前面cv2.contourArea()计算结果是一样的。质心也可以用算：


cx, cy = M['m10'] / M['m00'], M['m01'] / M['m00']  # (205, 281)

2.Knowledge02
本次目标是将一副图像从rgb颜色空间转换到hsv颜色空间，颜色去除白色背景部分

具体就调用了cv2的两个函数，一个是rgb转hsv的函数

具体用法

hsv = cv2.cvtColor(rgb_image, cv2.COLOR_BGR2HSV)
然后利用cv2.inRange函数设阈值，去除背景部分
  mask = cv2.inRange(hsv, lower_red, upper_red) #lower20===>0,upper200==>0,
函数很简单，参数有三个
第一个参数：hsv指的是原图

第二个参数：lower_red指的是图像中低于这个lower_red的值，图像值变为0

第三个参数：upper_red指的是图像中高于这个upper_red的值，图像值变为0

而在lower_red～upper_red之间的值变成255

lower_red = np.array([20, 20, 20])
upper_red = np.array([200, 200, 200])
mask = cv2.inRange(hsv, lower_red, upper_red) #lower20===>0,upper200==>0，lower～upper==>255

3.Knowledge03
腐蚀的具体操作：用一个结构元素(也可以说成操作数矩阵)一般为3×3大小的，
也可以看成一个卷积模板它们的区别就在于卷积模板是以算术运算为基础的，而结构元素是以集合运算为基础的，
扫描图像中的每一个像素(关于图像边缘的处理见下面详细分析)，用操作数矩阵扫描图像中的每一个像素，
操作数矩阵中每一个像素与覆盖的像素做“与”操作，如果全部为1，则图像中的该像素为1，反之为0，
而膨胀(dilate)操作正好相反，全部为0时，则图像素中的该像素为0，反之为1。

腐蚀的作用是消除物体的边界点，使目标缩小，这个根据操作的过程可以显然的想到，物体的边界处像素值肯定是有0和1，
腐蚀操作后这些紧邻着为1的像素点都会变成0，所以腐蚀操作会消除那些小的且无意义的物体，使边界向内部收缩的过程。
相反，膨胀(dilate)的作用当然是使目标增大，填充物体内细小的空洞，并且平滑物体的边界，边界向外部扩张的作用。

开运算是先腐蚀(erode)后膨胀(dilate)的过程，可以消除图像上细小的噪声，并平滑物体的边界

闭运算是先膨胀(dilate)后腐蚀(erode)的过程，可以填充物体内细小的空洞，并平滑物体边界

通常，由于噪声的影响，图象在阈值化后所得到边界往往是很不平滑的，物体区域具有一些噪声孔，
背景区域上散布着一些小的噪声物体。连续的开和闭运算可以有效地改善这种情况。有时需要经过多次腐蚀之后再加上相同次数的膨胀，
才可以产生比较好的效果。

腐蚀操作会去掉物体的边缘点，细小物体所有的点都会被认为是边缘点，因此会整个被删去。再做膨胀时，
留下来的大物体会变回原来的大小，而被删除的小物体则永远消失了。

膨胀操作会使物体的边界向外扩张，如果物体内部存在小空洞的话，经过膨胀操作这些洞将被补上，
因而不再是边界了。再进行腐蚀操作时，外部边界将变回原来的样子，而这些内部空洞则永远消失了。

4.Knowledge04
cv2.findContours(image, parameter1, parameter2)
参数
第一个参数是寻找轮廓的图像；

第二个参数表示轮廓的检索模式，有四种（本文介绍的都是新的cv2接口）：
    cv2.RETR_EXTERNAL表示只检测外轮廓
    cv2.RETR_LIST检测的轮廓不建立等级关系
    cv2.RETR_CCOMP建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。
    cv2.RETR_TREE建立一个等级树结构的轮廓。

第三个参数method为轮廓的近似办法
    cv2.CHAIN_APPROX_NONE存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1
    cv2.CHAIN_APPROX_SIMPLE压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息
    cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS使用teh-Chinl chain 近似算法

返回值
cv2.findContours()函数返回两个值，一个是轮廓本身，还有一个是每条轮廓对应的属性。

5.Knowledge05
cv2.minEnclosingCircle()

@return:
cv2.minEnclosingCircle函数会返回一个二元组，
第一个元素为圆心坐标组成的元组，
第二个元素为圆的半径值。










